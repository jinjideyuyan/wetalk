# 				   					 					正则表达式(一) 使用篇

## 前言

正则表达式(Regular Expression)，简写regex、regexp。

正则表达式使用特定的语法规则来描述一个字符串的特征，我们称之为一个  **模式(pattern)** 。

我们可以通过这个 **模式** 来 检索、替换  符合该模式的字符串。

正则表达式对字符串处理有着巨大的优势，得到了众多编程语言和Unix工具的支持。

我们可以用它来验证用户输入的数据，也可以用它来检索大量的文本、批量替换文本。

更进阶来讲，我们可以通过正则表达式来控制数据，让它们为自己服务。



在线练习的网站：https://regex101.com 。



## 好的习惯

**正则表达式是从左到右逐一字符进行匹配！！！** 

**模式(pattern)**  的最小的逻辑单位也是单个字符。

所以我们要养成按照字符来理解正则表达式的习惯。

比如：/apple/：匹配的是以a为第一个字符，紧接着是p、p、l，接着是一个e的文本。

而不是理解为匹配   "apple"  这个单词。

按字符理解可以让我们更好的记忆元字符，更容易理解正则表达式的内部逻辑。

## 基本用法

正则表达式的匹配分两种：一种是匹配字符，一种是匹配位置。

匹配字符：当前位置的字符 跟 **模式(pattern)** 中的字符是否匹配。

匹配位置：检查某个位置，是否符合   **模式(pattern)**  的要求。

我们来看下  **模式(pattern)**  的语法。

### 匹配字符

 **模式(pattern)**  由两种字符构成

- 普通字符(literal)：所见即所得，模式里什么字符就匹配什么字符，比如  模式("a")  匹配 字符 "a"。
- 元字符(metacharacters)：具有特殊含义的字符，不表示字符本身含义，表示特殊含义，比如 模式(".") 匹配 任意字符。

为了便于理解，我们可以把正则表达式想象为普通的语言，普通字符对应普通语言中 的单词，而元字符对应语法。根据语言的规则，按照语法把单词组合起来，就会得到能传达思想的文本。在 E-mail 的例子中，我用正则表达式来寻找 以‘From:’或者‘Subject:’开头的行。下画线标注的就是特殊字符，稍后我们将解释它们的含义。

#### 普通字符

![企业微信20210415050530](/Users/tyrion/Desktop/work/企业微信20210415050530.png)

#### 字符组

字符组容许使用者列出在某处期望匹配的字符

如果我们需要搜索的是单词“grey”，同时又不确定它是否写作“gray”，就可以使用正则表达式结构体(construct)「[...]」。它容许使用者列出在某处期望匹配的字符，通常

被称作字符组。「e」匹配字符e，「a」匹配字符a，而正则表

达式「[ea]」能匹配a或者e。所以，「gr[ea]y」的意思是:先找到g，跟着是一个r，然后是

一个a或者e，最后是一个y。

请注意，在字符组以外，普通字符(例如「gr[ae]y」中的「g」和「r」)都有“接下来 是(and then)”的意思——“首先匹配「g」，接下来是「r」......”。这与字符组内部的情况是完全相反的。字符组的内容是在同一个位置能够匹配的若干字符，所以它的意思 是“或”。

来看另一个例子，我们还必须考虑单词的第一个字母为大写的情况，例如

「[Ss]mith」。请记住，这个表达式仍然能够匹配内嵌在其他单词里头的 smith(或者是

Smith)，例如blacksmith。在综述阶段，我不打算为这种情况费太多笔墨，但是这确实是 某些新手遇到的问题的根源。等了解了更多的元字符以后，我会介绍一些办法来解决单词 嵌套的问题。在一个字符组中可以列举任意多个字符。例如「[123456]」匹配1到6中的任

意一个数字。这个字符组可以作为「<H[123456]>」的一部分，用来匹配<H1>、<H2 >、<H3>等等。在搜索HTML代码的头文件时这非常有用。

在字符组内部，字符组元字符(character-class metacharacter)‘-’(连字符)表示一个 范围:「<H[1-6]>」与「<H[123456]>」是完全一样的。「[0-9]」和「[a-z]」是常用的匹 配数字和小写字母的简便方式。多重范围也是容许的，例如 「[0123456789abcdefABCDEF]」可以写作「[0-9a-fA-F]」(或者也可以写作「[A-Fa-f0- 9]」，顺序无所谓)。这3个正则表达式非常适用于处理十六进制数字。我们还可以随心 所欲地把字符范围与普通文本结合起来:「[0-9A-Z_!.?]」能够匹配一个数字、大写字 母、下画线、惊叹号、点号，或者是问号。

请注意，只有在字符组内部，连字符才是元字符——否则它就只能匹配普通的连字符 号。其实，即使在字符组内部，它也不一定就是元字符。如果连字符出现在字符组的开 头，它表示的就只是一个普通字符，而不是一个范围。同样的道理，问号和点号通常被当 作元字符处理，但在字符组中则不是如此(说明白一点就是，「[0-9A-Z_!.?]」里面，

真正的特殊字符就只有那两个连字符)。

#### 字符组的兄弟

| 字符 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  \   |                            转义符                            |
|  \d  |                   [0-9]。表示是一位数字。                    |
|  \D  |               [^0-9]。表示除数字外的任意字符。               |
|  \w  |         [0-9a-zA-Z_]。表示数字、大小写字母和下划线。         |
|  \W  |                 [^0-9a-zA-Z_]。非单词字符。                  |
|  \s  | [\t\v\n\r\f]。表示空白符，包括空格、水平制表符、 垂直制表符、换行符、回车符、换页符。 |
|  \S  |                  [^\t\v\n\r\f]。 非空白符。                  |

#### 点号匹配任意字符

#### 转义字符

### 匹配位置

脱字符号和美元符号的特别之处就在于，它们匹配的是一个位置，而不是具体的文本。

#### 字符串分界符

#### 单词分界符

#### 环视功能

### 量词

|  字符  |        说明         |
| :----: | :-----------------: |
|   a*   |      0 or more      |
|   a+   |      1 or more      |
|   a?   |       0 or 1        |
|  a{5}  |    exactly five     |
| a{2,}  |     two or more     |
| a{1,3} | between one & three |

### 修饰符

| 字符 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  i   |                  执行对大小写不敏感的匹配。                  |
|  g   |   执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。   |
|  m   |                        执行多行匹配。                        |
|  u   | 开启"Unicode 模式"，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 |
|  s   |                     允许 . 匹配换行符。                      |
|  y   | y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是"粘连"的涵义 |

## 环视功能

顺序环视的意义：检查某个位置，但检查时匹配的字符串并不在（最终）“匹配的字符串”内

```shell
增强的行锚点”(enhanced line anchor)匹配模式
```

画思维导图

## 匹配 & 替换

## 历史流派 & 标准化

画时间轴

Perl特殊换行指定

